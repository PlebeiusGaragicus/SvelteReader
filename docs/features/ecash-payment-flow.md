# Ecash Payment Flow Design

This document describes the payment flow for AI chat messages in SvelteReader, using CypherTap ecash tokens with a refund-safe design.

## Overview

SvelteReader uses a **pay-per-message** model where users pay 1 sat (configurable) per AI chat message using Cashu ecash tokens generated by CypherTap. The design prioritizes **zero fund loss** - if anything goes wrong, the user keeps their funds.

## Design Goals

1. **Zero fund loss** - Users never lose funds due to errors
2. **Simple UX** - Payment happens seamlessly in the background
3. **Atomic operations** - Either the message succeeds and payment is taken, or both fail
4. **Self-recovery** - Client can recover funds without server cooperation

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    CLIENT (SvelteReader + CypherTap)             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐       │
│  │   CypherTap  │───▶│  Chat Store  │───▶│  LangGraph   │       │
│  │   Wallet     │    │  (pending    │    │  Service     │       │
│  │              │    │   tokens)    │    │              │       │
│  └──────────────┘    └──────────────┘    └──────────────┘       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    AGENT (LangGraph + Nutstash)                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐       │
│  │   Validate   │───▶│   Process    │───▶│   Redeem     │       │
│  │   Token      │    │   LLM        │    │   Token      │       │
│  │   (NUT-07)   │    │              │    │   (Nutstash) │       │
│  └──────────────┘    └──────────────┘    └──────────────┘       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Payment Flow

### Happy Path

```
1. User types message and clicks send
2. Client generates ecash token via CypherTap (deducts from wallet)
3. Client stores token locally as "pending" 
4. Client sends {message, token} to LangGraph agent
5. Agent validates token is UNSPENT via Cashu NUT-07
6. Agent processes LLM request
7. Agent redeems token to Nutstash wallet
8. Agent returns successful response
9. Client receives response, clears pending token
10. User sees AI response
```

### Error Path (LLM Failure)

```
1-5. Same as happy path
6. Agent processes LLM request → FAILS
7. Agent does NOT redeem token
8. Agent returns error response with refund flag
9. Client receives error with refund=true
10. Client calls cyphertap.receiveEcashToken(pendingToken)
11. User's funds are restored to wallet
```

### Error Path (Network/Timeout)

```
1-4. Same as happy path
5. Network fails or request times out
6. Client detects timeout
7. Client checks token state via NUT-07 (optional)
8. If token is UNSPENT → Client self-redeems via receiveEcashToken()
9. User's funds are restored to wallet
```

## Key Design Decisions

### 1. Validate-Then-Redeem (Not Redeem-Then-Process)

**Why**: If we redeem first and the LLM fails, we've taken the user's money for nothing. By validating first and only redeeming on success, we ensure atomicity.

**Trade-off**: The agent does work before being paid. This opens a small DoS vector, but the work (one LLM call) is bounded and the validation step filters out invalid tokens.

### 2. Client Holds Token Until Redeemed

**Why**: The ecash token is a bearer instrument. Whoever holds it can redeem it. By keeping the token on the client until the agent explicitly redeems it, the client can always self-recover.

**Implementation**: Client stores the token string in local state before sending. On error, it can call `receiveEcashToken()` to reclaim the funds.

### 3. NUT-07 Token State Check

**Why**: Cashu NUT-07 allows checking if a token is `UNSPENT`, `PENDING`, or `SPENT` without redeeming it. This lets us:
- Validate the token is real and unspent before processing
- Allow clients to check token state for recovery

**Endpoint**: `POST /v1/checkstate` on the mint

### 4. Refund Flag in Response

**Why**: The agent explicitly tells the client whether to attempt a refund. This handles edge cases where the token might have been partially processed.

**Response format**:
```json
{
  "success": false,
  "error": "LLM processing failed",
  "refund": true
}
```

## Implementation Details

### Client Side (Frontend)

#### Pending Token Storage

```typescript
// In chat store or component state
let pendingPayment: {
  token: string;
  messageId: string;
  timestamp: number;
} | null = null;
```

#### Message Submission Flow

```typescript
async function sendMessage(content: string) {
  // 1. Generate payment token
  const { token } = await cyphertap.generateEcashToken(
    MESSAGE_COST_SATS,
    'AI chat message'
  );
  
  // 2. Store as pending (for potential refund)
  pendingPayment = {
    token,
    messageId: crypto.randomUUID(),
    timestamp: Date.now()
  };
  
  try {
    // 3. Send to agent
    const response = await submitMessage(content, { payment: { token } });
    
    // 4. Success - clear pending (token was redeemed by agent)
    pendingPayment = null;
    
    return response;
  } catch (error) {
    // 5. Error - attempt refund
    if (pendingPayment) {
      await attemptRefund(pendingPayment.token);
      pendingPayment = null;
    }
    throw error;
  }
}

async function attemptRefund(token: string) {
  try {
    const result = await cyphertap.receiveEcashToken(token);
    console.log(`Refunded ${result.amount} sats`);
  } catch (e) {
    // Token may have been spent - check state
    console.warn('Refund failed - token may have been redeemed');
  }
}
```

#### Timeout Recovery

```typescript
// On app startup or periodically
async function recoverPendingPayments() {
  const pending = loadPendingPaymentsFromStorage();
  
  for (const payment of pending) {
    // If older than timeout threshold, attempt recovery
    if (Date.now() - payment.timestamp > PAYMENT_TIMEOUT_MS) {
      await attemptRefund(payment.token);
      removePendingPayment(payment.messageId);
    }
  }
}
```

### Agent Side (Python)

#### Token Validation (NUT-07)

```python
async def validate_token(token: str, mint_url: str) -> bool:
    """Check if token is valid and unspent via NUT-07."""
    # Parse token to extract proofs
    token_data = decode_cashu_token(token)
    
    # Calculate Y values for each proof
    ys = [hash_to_curve(proof.secret) for proof in token_data.proofs]
    
    async with httpx.AsyncClient() as client:
        response = await client.post(
            f"{mint_url}/v1/checkstate",
            json={"Ys": ys}
        )
        
        if response.status_code != 200:
            return False
            
        states = response.json()["states"]
        
        # All proofs must be UNSPENT
        return all(s["state"] == "UNSPENT" for s in states)
```

#### Payment Node Flow

```python
async def verify_payment_node(state: AgentState) -> dict:
    """Validate token without redeeming."""
    payment = state.get("payment")
    
    if not payment or not payment.get("ecash_token"):
        # No payment required (dev mode)
        return {"payment_verified": True, "payment_token": None}
    
    token = payment["ecash_token"]
    
    # Validate token is unspent (don't redeem yet)
    is_valid = await validate_token(token, MINT_URL)
    
    if not is_valid:
        return {
            "payment_verified": False,
            "payment_token": None,
            "error": "Invalid or already spent token"
        }
    
    # Token is valid - pass it through for later redemption
    return {
        "payment_verified": True,
        "payment_token": token
    }


async def chat_node(state: AgentState) -> dict:
    """Process LLM and redeem on success."""
    if not state.get("payment_verified"):
        return {"messages": [AIMessage(content="Payment required")]}
    
    try:
        # Process LLM
        response = await model.ainvoke(messages)
        
        # Success - now redeem the token
        token = state.get("payment_token")
        if token:
            await redeem_to_nutstash(token)
        
        return {"messages": [response], "refund": False}
        
    except Exception as e:
        # Failure - don't redeem, signal refund
        return {
            "messages": [AIMessage(content=f"Error: {e}")],
            "refund": True
        }
```

## Edge Cases

| Scenario | Token State | Client Action | Outcome |
|----------|-------------|---------------|---------|
| LLM succeeds | SPENT (by agent) | Clear pending | ✅ Normal flow |
| LLM fails | UNSPENT | Self-redeem | ✅ Full refund |
| Network timeout | UNSPENT | Self-redeem | ✅ Full refund |
| Agent crashes before redeem | UNSPENT | Self-redeem | ✅ Full refund |
| Agent crashes after redeem | SPENT | Refund fails | ⚠️ Funds with agent |
| Double-spend attempt | SPENT/PENDING | Validation fails | ✅ Rejected |
| Invalid token | N/A | Validation fails | ✅ Rejected |

## Configuration

### Environment Variables

**Frontend (.env)**:
```
VITE_MESSAGE_COST_SATS=1
```

**Agent (.env)**:
```
NUTSTASH_URL=http://localhost:3338
MINT_URL=https://mint.minibits.cash/Bitcoin
```

## Security Considerations

1. **Token exposure**: Tokens are sent over HTTPS. Consider additional encryption for high-value tokens.

2. **DoS protection**: Agent does work before payment. Rate limiting and token validation help mitigate.

3. **Mint trust**: Both client and agent must trust the Cashu mint. Use reputable mints.

4. **Token replay**: NUT-07 validation prevents replay attacks.

## Known Issues & Fixes

### CashuB Token Format (CBOR Encoding)

**Issue**: Cashu tokens come in two formats:
- `cashuA`: Base64url-encoded **JSON**
- `cashuB`: Base64url-encoded **CBOR** (binary)

The original implementation tried to parse all tokens as JSON, which failed for `cashuB` tokens with:
```
'utf-8' codec can't decode byte 0xa4 in position 0: invalid start byte
```

**Fix**: The agent now only validates the token format (prefix + valid base64url) without parsing the content. The actual token parsing and redemption is handled by nutstash, which supports both formats.

```python
def validate_token_format(token: str) -> bool:
    """Validate token has correct prefix and is valid base64url."""
    if not (token.startswith("cashuA") or token.startswith("cashuB")):
        return False
    
    token_data = token[6:]
    # Add padding and decode to verify it's valid base64url
    decoded = base64.urlsafe_b64decode(token_data + "=" * (4 - len(token_data) % 4))
    return len(decoded) >= 10
```

**Lesson**: Don't assume token content format. Validate structure, let the wallet handle parsing.

## Future Improvements

1. **Spending conditions (NUT-10/11)**: Use P2PK or HTLC conditions for atomic swaps
2. **Escrow service**: Third-party escrow for high-value transactions
3. **Batch payments**: Pay for multiple messages in one token
4. **Subscription model**: Prepaid message bundles
5. **CBOR parsing**: Add proper CBOR library for full NUT-07 validation of cashuB tokens

## References

- [Cashu Protocol](https://docs.cashu.space/protocol)
- [NUT-07: Token State Check](https://github.com/cashubtc/nuts/blob/main/07.md)
- [CypherTap Documentation](../cyphertap/README.md)
- [LangGraph Documentation](https://langchain-ai.github.io/langgraph/)
